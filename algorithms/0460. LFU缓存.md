> Accepted
23/23 cases passed (27 ms)
Your runtime beats 56.13 % of java submissions
Your memory usage beats 97.95 % of java submissions (46.4 MB)

23ä¸ªcaseï¼Œèƒ½æµ‹å‡ºå•¥å‘€ã€‚ã€‚

LFUä¹Ÿæœ‰æ—¶åºï¼Œå³å½“è®¡æ•°ç›¸åŒçš„æƒ…å†µä¸‹ï¼Œæœ€å…ˆè¢«åŠ å…¥çš„æ˜¯æœ€å…ˆè¢«æ·˜æ±°çš„ï¼Œè¿™æ˜¯å±€éƒ¨çš„FIFOç­–ç•¥ï¼Œå¯ä»¥ç›¸åŒè®¡æ•°å¯ä»¥ç”¨ä¸€ä¸ªé˜Ÿåˆ—ã€‚ä½†æ˜¯ä¸€ä¸ªitem count+1æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä»åŸæ¥çš„counté˜Ÿåˆ—é‡Œåˆ é™¤æŒ‡å®šitemçš„keyï¼Œè¿™ç”¨ä¼¼ä¹ç”¨å“ˆå¸Œåˆæ›´å¥½ï¼Œå…¶å®ï¼Œåˆæ˜¯æœ‰åºåˆæ˜¯å“ˆå¸Œçš„ï¼Œç”¨Javaçš„LinkedHashSetå°±å¥½äº†ï¼ŒLRUé‚£é“é¢˜å·²ç»é€ è¿‡è½®å­äº†ï¼Œè¿™é¢˜ç›´æ¥ç”¨ã€‚

```java
class LFUCache {
    Map<Integer, LFUNode> key2Value = new HashMap<>();
    Map<Integer, Set<Integer>> count2keys = new HashMap<>();

    int minCount;
    int capacity;
    int curSize = 0;

    // æ„Ÿè§‰ğŸ¤¯å•Š
    public LFUCache(int capacity) {
        this.capacity = capacity;
    }

    public int get(int key) {
        if (capacity == 0) {
            return -1;
        }
        LFUNode cacheItem = key2Value.get(key);
        if (cacheItem != null) {
            int count = ++cacheItem.count;
            cacheItem.countSet.remove(key);
            cacheItem.countSet = count2keys.computeIfAbsent(count, k -> new LinkedHashSet<>());
            cacheItem.countSet.add(key);
            updateMinCount(count);
            return cacheItem.value;
        }
        return -1;
    }

    public void put(int key, int value) {
        if (capacity == 0) {
            return;
        }
        LFUNode cacheItem = key2Value.get(key);
        if (cacheItem != null) {
            cacheItem.value = value;
            int count = ++cacheItem.count;
            cacheItem.countSet.remove(key);
            cacheItem.countSet = count2keys.computeIfAbsent(count, k -> new LinkedHashSet<>());
            cacheItem.countSet.add(key);
            updateMinCount(count);
            return;
        }

        if (curSize == capacity) {
            Set<Integer> set = count2keys.get(minCount);
            Integer key2Remove = removeOldest(set);
            LFUNode cacheItemToRemove = key2Value.remove(key2Remove);;
            cacheItemToRemove.countSet.remove(key);
        } else {
            curSize ++;
        }
        // åˆå§‹åŒ– key2Value
        cacheItem = new LFUNode();
        cacheItem.value = value;
        cacheItem.count = 1;
        cacheItem.countSet = count2keys.computeIfAbsent(1, k -> new LinkedHashSet<>());
        cacheItem.countSet.add(key);
        key2Value.put(key, cacheItem);
        minCount = 1;
    }

    public void updateMinCount(int newCount){
        if (newCount - 1 == minCount) {
            if (count2keys.get(minCount).isEmpty()) {
                minCount = newCount;
            }
        }
    }

    public <K> K removeOldest(Set<K> set) {
        Iterator<K> it = set.iterator();
        K k = it.next();
        it.remove();
        return k;
    }
}

class LFUNode{
    int count;
    int value;
    Set<Integer> countSet;
}
```